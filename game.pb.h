// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef PROTOBUF_game_2eproto__INCLUDED
#define PROTOBUF_game_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace game {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_game_2eproto();
void protobuf_AssignDesc_game_2eproto();
void protobuf_ShutdownFile_game_2eproto();

class User;
class Board;
class Move;
class Game;

// ===================================================================

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bool human = 2;
  inline bool has_human() const;
  inline void clear_human();
  static const int kHumanFieldNumber = 2;
  inline bool human() const;
  inline void set_human(bool value);

  // optional int32 score = 3 [default = 0];
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // required string symbol = 4;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // @@protoc_insertion_point(class_scope:game.User)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_human();
  inline void clear_has_human();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_symbol();
  inline void clear_has_symbol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  bool human_;
  ::google::protobuf::int32 score_;
  ::std::string* symbol_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class Board : public ::google::protobuf::Message {
 public:
  Board();
  virtual ~Board();

  Board(const Board& from);

  inline Board& operator=(const Board& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Board& default_instance();

  void Swap(Board* other);

  // implements Message ----------------------------------------------

  Board* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Board& from);
  void MergeFrom(const Board& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:game.Board)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Board* default_instance_;
};
// -------------------------------------------------------------------

class Move : public ::google::protobuf::Message {
 public:
  Move();
  virtual ~Move();

  Move(const Move& from);

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Move& default_instance();

  void Swap(Move* other);

  // implements Message ----------------------------------------------

  Move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required string symbol = 3;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // @@protoc_insertion_point(class_scope:game.Move)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_symbol();
  inline void clear_has_symbol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::std::string* symbol_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Move* default_instance_;
};
// -------------------------------------------------------------------

class Game : public ::google::protobuf::Message {
 public:
  Game();
  virtual ~Game();

  Game(const Game& from);

  inline Game& operator=(const Game& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Game& default_instance();

  void Swap(Game* other);

  // implements Message ----------------------------------------------

  Game* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Game& from);
  void MergeFrom(const Game& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .game.User user = 1;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::game::User& user(int index) const;
  inline ::game::User* mutable_user(int index);
  inline ::game::User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::game::User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::game::User >*
      mutable_user();

  // optional .game.Board board = 2;
  inline bool has_board() const;
  inline void clear_board();
  static const int kBoardFieldNumber = 2;
  inline const ::game::Board& board() const;
  inline ::game::Board* mutable_board();
  inline ::game::Board* release_board();
  inline void set_allocated_board(::game::Board* board);

  // required int32 options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 3;
  inline ::google::protobuf::int32 options() const;
  inline void set_options(::google::protobuf::int32 value);

  // repeated .game.Move mem = 4;
  inline int mem_size() const;
  inline void clear_mem();
  static const int kMemFieldNumber = 4;
  inline const ::game::Move& mem(int index) const;
  inline ::game::Move* mutable_mem(int index);
  inline ::game::Move* add_mem();
  inline const ::google::protobuf::RepeatedPtrField< ::game::Move >&
      mem() const;
  inline ::google::protobuf::RepeatedPtrField< ::game::Move >*
      mutable_mem();

  // required string turnFor = 5;
  inline bool has_turnfor() const;
  inline void clear_turnfor();
  static const int kTurnForFieldNumber = 5;
  inline const ::std::string& turnfor() const;
  inline void set_turnfor(const ::std::string& value);
  inline void set_turnfor(const char* value);
  inline void set_turnfor(const char* value, size_t size);
  inline ::std::string* mutable_turnfor();
  inline ::std::string* release_turnfor();
  inline void set_allocated_turnfor(::std::string* turnfor);

  // @@protoc_insertion_point(class_scope:game.Game)
 private:
  inline void set_has_board();
  inline void clear_has_board();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_turnfor();
  inline void clear_has_turnfor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::game::User > user_;
  ::game::Board* board_;
  ::google::protobuf::RepeatedPtrField< ::game::Move > mem_;
  ::std::string* turnfor_;
  ::google::protobuf::int32 options_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Game* default_instance_;
};
// ===================================================================


// ===================================================================

// User

// required string name = 1;
inline bool User::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& User::name() const {
  // @@protoc_insertion_point(field_get:game.User.name)
  return *name_;
}
inline void User::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:game.User.name)
}
inline void User::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:game.User.name)
}
inline void User::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:game.User.name)
}
inline ::std::string* User::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:game.User.name)
  return name_;
}
inline ::std::string* User::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void User::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:game.User.name)
}

// required bool human = 2;
inline bool User::has_human() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_human() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_human() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_human() {
  human_ = false;
  clear_has_human();
}
inline bool User::human() const {
  // @@protoc_insertion_point(field_get:game.User.human)
  return human_;
}
inline void User::set_human(bool value) {
  set_has_human();
  human_ = value;
  // @@protoc_insertion_point(field_set:game.User.human)
}

// optional int32 score = 3 [default = 0];
inline bool User::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 User::score() const {
  // @@protoc_insertion_point(field_get:game.User.score)
  return score_;
}
inline void User::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:game.User.score)
}

// required string symbol = 4;
inline bool User::has_symbol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_symbol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& User::symbol() const {
  // @@protoc_insertion_point(field_get:game.User.symbol)
  return *symbol_;
}
inline void User::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:game.User.symbol)
}
inline void User::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:game.User.symbol)
}
inline void User::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:game.User.symbol)
}
inline ::std::string* User::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:game.User.symbol)
  return symbol_;
}
inline ::std::string* User::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void User::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:game.User.symbol)
}

// -------------------------------------------------------------------

// Board

// required int32 x = 1;
inline bool Board::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Board::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Board::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Board::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Board::x() const {
  // @@protoc_insertion_point(field_get:game.Board.x)
  return x_;
}
inline void Board::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:game.Board.x)
}

// required int32 y = 2;
inline bool Board::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Board::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Board::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Board::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Board::y() const {
  // @@protoc_insertion_point(field_get:game.Board.y)
  return y_;
}
inline void Board::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:game.Board.y)
}

// -------------------------------------------------------------------

// Move

// required int32 x = 1;
inline bool Move::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Move::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Move::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Move::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Move::x() const {
  // @@protoc_insertion_point(field_get:game.Move.x)
  return x_;
}
inline void Move::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:game.Move.x)
}

// required int32 y = 2;
inline bool Move::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Move::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Move::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Move::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Move::y() const {
  // @@protoc_insertion_point(field_get:game.Move.y)
  return y_;
}
inline void Move::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:game.Move.y)
}

// required string symbol = 3;
inline bool Move::has_symbol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Move::set_has_symbol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Move::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Move::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& Move::symbol() const {
  // @@protoc_insertion_point(field_get:game.Move.symbol)
  return *symbol_;
}
inline void Move::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:game.Move.symbol)
}
inline void Move::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:game.Move.symbol)
}
inline void Move::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:game.Move.symbol)
}
inline ::std::string* Move::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:game.Move.symbol)
  return symbol_;
}
inline ::std::string* Move::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Move::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:game.Move.symbol)
}

// -------------------------------------------------------------------

// Game

// repeated .game.User user = 1;
inline int Game::user_size() const {
  return user_.size();
}
inline void Game::clear_user() {
  user_.Clear();
}
inline const ::game::User& Game::user(int index) const {
  // @@protoc_insertion_point(field_get:game.Game.user)
  return user_.Get(index);
}
inline ::game::User* Game::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:game.Game.user)
  return user_.Mutable(index);
}
inline ::game::User* Game::add_user() {
  // @@protoc_insertion_point(field_add:game.Game.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::game::User >&
Game::user() const {
  // @@protoc_insertion_point(field_list:game.Game.user)
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::game::User >*
Game::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:game.Game.user)
  return &user_;
}

// optional .game.Board board = 2;
inline bool Game::has_board() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Game::set_has_board() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Game::clear_has_board() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Game::clear_board() {
  if (board_ != NULL) board_->::game::Board::Clear();
  clear_has_board();
}
inline const ::game::Board& Game::board() const {
  // @@protoc_insertion_point(field_get:game.Game.board)
  return board_ != NULL ? *board_ : *default_instance_->board_;
}
inline ::game::Board* Game::mutable_board() {
  set_has_board();
  if (board_ == NULL) board_ = new ::game::Board;
  // @@protoc_insertion_point(field_mutable:game.Game.board)
  return board_;
}
inline ::game::Board* Game::release_board() {
  clear_has_board();
  ::game::Board* temp = board_;
  board_ = NULL;
  return temp;
}
inline void Game::set_allocated_board(::game::Board* board) {
  delete board_;
  board_ = board;
  if (board) {
    set_has_board();
  } else {
    clear_has_board();
  }
  // @@protoc_insertion_point(field_set_allocated:game.Game.board)
}

// required int32 options = 3;
inline bool Game::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Game::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Game::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Game::clear_options() {
  options_ = 0;
  clear_has_options();
}
inline ::google::protobuf::int32 Game::options() const {
  // @@protoc_insertion_point(field_get:game.Game.options)
  return options_;
}
inline void Game::set_options(::google::protobuf::int32 value) {
  set_has_options();
  options_ = value;
  // @@protoc_insertion_point(field_set:game.Game.options)
}

// repeated .game.Move mem = 4;
inline int Game::mem_size() const {
  return mem_.size();
}
inline void Game::clear_mem() {
  mem_.Clear();
}
inline const ::game::Move& Game::mem(int index) const {
  // @@protoc_insertion_point(field_get:game.Game.mem)
  return mem_.Get(index);
}
inline ::game::Move* Game::mutable_mem(int index) {
  // @@protoc_insertion_point(field_mutable:game.Game.mem)
  return mem_.Mutable(index);
}
inline ::game::Move* Game::add_mem() {
  // @@protoc_insertion_point(field_add:game.Game.mem)
  return mem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::game::Move >&
Game::mem() const {
  // @@protoc_insertion_point(field_list:game.Game.mem)
  return mem_;
}
inline ::google::protobuf::RepeatedPtrField< ::game::Move >*
Game::mutable_mem() {
  // @@protoc_insertion_point(field_mutable_list:game.Game.mem)
  return &mem_;
}

// required string turnFor = 5;
inline bool Game::has_turnfor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Game::set_has_turnfor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Game::clear_has_turnfor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Game::clear_turnfor() {
  if (turnfor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    turnfor_->clear();
  }
  clear_has_turnfor();
}
inline const ::std::string& Game::turnfor() const {
  // @@protoc_insertion_point(field_get:game.Game.turnFor)
  return *turnfor_;
}
inline void Game::set_turnfor(const ::std::string& value) {
  set_has_turnfor();
  if (turnfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    turnfor_ = new ::std::string;
  }
  turnfor_->assign(value);
  // @@protoc_insertion_point(field_set:game.Game.turnFor)
}
inline void Game::set_turnfor(const char* value) {
  set_has_turnfor();
  if (turnfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    turnfor_ = new ::std::string;
  }
  turnfor_->assign(value);
  // @@protoc_insertion_point(field_set_char:game.Game.turnFor)
}
inline void Game::set_turnfor(const char* value, size_t size) {
  set_has_turnfor();
  if (turnfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    turnfor_ = new ::std::string;
  }
  turnfor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:game.Game.turnFor)
}
inline ::std::string* Game::mutable_turnfor() {
  set_has_turnfor();
  if (turnfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    turnfor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:game.Game.turnFor)
  return turnfor_;
}
inline ::std::string* Game::release_turnfor() {
  clear_has_turnfor();
  if (turnfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = turnfor_;
    turnfor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Game::set_allocated_turnfor(::std::string* turnfor) {
  if (turnfor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete turnfor_;
  }
  if (turnfor) {
    set_has_turnfor();
    turnfor_ = turnfor;
  } else {
    clear_has_turnfor();
    turnfor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:game.Game.turnFor)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace game

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_2eproto__INCLUDED
